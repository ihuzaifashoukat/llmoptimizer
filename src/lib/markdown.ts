import type { PageExtract, SiteSummary, StructuredRenderOptions } from './types'

export function toMarkdown(site: SiteSummary, pages: PageExtract[]): string {
  const lines: string[] = []
  lines.push(`# llms.txt — Site Summary`)
  lines.push(`Generated By: [llmoptimizer](https://github.com/ihuzaifashoukat/llmoptimizer) by Huzaifa Shoukat`)
  if (site.baseUrl) lines.push(`Base URL: ${site.baseUrl}`)
  lines.push(`Generated: ${site.generatedAt}`)
  if (site.locales?.length) lines.push(`Locales: ${site.locales.join(', ')}`)
  lines.push('')
  lines.push('## Pages')
  if (!pages.length) {
    lines.push('No pages found. If this is unexpected, ensure your build outputs HTML or provide a baseUrl for crawl/adapter mode. You can also adjust include/exclude patterns.')
    lines.push('')
  }
  for (const p of pages) {
    lines.push(`### ${p.title || p.url}`)
    lines.push(`URL: ${p.url}`)
    if (p.locale) lines.push(`Locale: ${p.locale}`)
    if (p.dir) lines.push(`Dir: ${p.dir}`)
    if (p.lastModified) lines.push(`Last Modified: ${p.lastModified}`)
    if (p.canonical) lines.push(`Canonical: ${p.canonical}`)
    if (p.description) lines.push(`Description: ${p.description}`)
    if (p.og && Object.keys(p.og).length) lines.push(`OpenGraph: ${JSON.stringify(p.og)}`)
    if (p.twitter && Object.keys(p.twitter).length) lines.push(`Twitter: ${JSON.stringify(p.twitter)}`)
    if (p.hreflang?.length) lines.push(`Alternate Locales: ${p.hreflang.map((h) => `${h.lang}:${h.href}`).join(' | ')}`)
    if (p.robotsMeta) lines.push(`Robots: ${p.robotsMeta}`)
    if (p.meta?.keywords?.length) lines.push(`Keywords: ${p.meta.keywords.join(', ')}`)
    if (p.meta?.viewport) lines.push(`Viewport: ${p.meta.viewport}`)
    if (p.meta?.charset) lines.push(`Charset: ${p.meta.charset}`)
    if (p.meta?.generator) lines.push(`Generator: ${p.meta.generator}`)
    if (p.headings.length) {
      lines.push('Headings:')
      for (const h of p.headings.slice(0, 20)) {
        lines.push(`- ${h.tag.toUpperCase()}: ${h.text}`)
      }
    }
    if (p.contentSnippet) {
      lines.push('Content Snippet:')
      lines.push(`> ${p.contentSnippet}`)
    }
    if (typeof p.internalLinks === 'number' || typeof p.externalLinks === 'number') {
      lines.push(`Links: internal=${p.internalLinks ?? 0}, external=${p.externalLinks ?? 0}`)
    }
    if (p.links.length) {
      lines.push('Important Links:')
      for (const l of p.links.slice(0, 15)) {
        const text = l.text || '(no text)'
        const rel = l.rel ? ` rel=${l.rel}` : ''
        lines.push(`- [${text}](${l.href})${rel}`)
      }
    }
    if (typeof p.imageCount === 'number') lines.push(`Images: total=${p.imageCount} missingAlt=${p.imagesMissingAlt ?? 0}`)
    if (p.images?.length) {
      lines.push('Images sample:')
      for (const img of p.images.slice(0, 10)) {
        lines.push(`- ${img.src} alt="${img.alt ?? ''}"`)
      }
    }
    if (p.jsonLd.length) {
      lines.push('JSON-LD Types: ' + summarizeJsonLdTypes(p.jsonLd).join(', '))
    }
    if (p.breadcrumbs?.length) {
      lines.push('Breadcrumbs: ' + p.breadcrumbs.join(' > '))
    }
    lines.push('')
  }

  return lines.join('\n') + '\n'
}

export function renderMarkdown(site: SiteSummary, pages: PageExtract[], theme: 'default' | 'compact' | 'detailed' | 'structured' = 'structured', options?: StructuredRenderOptions): string {
  if (theme === 'compact') return toCompactMarkdown(site, pages)
  if (theme === 'detailed') return toDetailedMarkdown(site, pages)
  if (theme === 'structured') return toStructuredMarkdown(site, pages, options)
  return toMarkdown(site, pages)
}

function toCompactMarkdown(site: SiteSummary, pages: PageExtract[]): string {
  const lines: string[] = []
  lines.push(`# llms.txt — Site Summary`)
  lines.push(`Generated By: [llmoptimizer](https://github.com/ihuzaifashoukat/llmoptimizer) by Huzaifa Shoukat`)
  if (site.baseUrl) lines.push(`Base URL: ${site.baseUrl}`)
  lines.push(`Generated: ${site.generatedAt}`)
  lines.push('')
  lines.push('## Pages (compact)')
  if (!pages.length) {
    lines.push('- (no pages found; consider crawl mode or check include/exclude)')
    return lines.join('\n') + '\n'
  }
  for (const p of pages) {
    const title = p.title ? `“${p.title}”` : ''
    const desc = p.description ? ` — ${p.description.slice(0, 120)}` : ''
    const last = p.lastModified ? ` [Last Modified: ${p.lastModified}]` : ''
    lines.push(`- ${p.url} ${title}${desc}${last}`)
  }
  return lines.join('\n') + '\n'
}

function toDetailedMarkdown(site: SiteSummary, pages: PageExtract[]): string {
  const lines: string[] = []
  lines.push(`# llms.txt — Site Summary (Detailed)`)
  lines.push(`Generated By: [llmoptimizer](https://github.com/ihuzaifashoukat/llmoptimizer) by Huzaifa Shoukat`)
  if (site.baseUrl) lines.push(`Base URL: ${site.baseUrl}`)
  lines.push(`Generated: ${site.generatedAt}`)
  if (site.locales?.length) lines.push(`Locales: ${site.locales.join(', ')}`)

  // Aggregate metrics
  if (!pages.length) {
    lines.push('', 'Pages: 0', '', 'No pages found. If this is unexpected, ensure your build outputs HTML or provide a baseUrl for crawl/adapter mode.')
    return lines.join('\n') + '\n'
  }
  const totals = pages.reduce(
    (acc, p) => {
      acc.words += p.wordCount || 0
      acc.images += p.imageCount || 0
      acc.missingAlt += p.imagesMissingAlt || 0
      acc.internal += p.internalLinks || 0
      acc.external += p.externalLinks || 0
      return acc
    },
    { words: 0, images: 0, missingAlt: 0, internal: 0, external: 0 }
  )
  lines.push(`Pages: ${pages.length}`)
  lines.push(`Totals: words=${totals.words} images=${totals.images} missingAlt=${totals.missingAlt} internalLinks=${totals.internal} externalLinks=${totals.external}`)
  lines.push('')

  // Table of contents
  lines.push('## Table of Contents')
  pages.forEach((p, i) => {
    const anchor = `page-${i + 1}`
    lines.push(`- [${p.title || p.url}](#${anchor})`)
  })
  lines.push('')

  // Pages
  pages.forEach((p, i) => {
    const anchor = `page-${i + 1}`
    lines.push(`---`)
    lines.push(`<a id="${anchor}"></a>`)
    lines.push(`### ${p.title || p.url}`)
    lines.push(`URL: ${p.url}`)
    if (p.locale) lines.push(`Locale: ${p.locale}`)
    if (p.dir) lines.push(`Dir: ${p.dir}`)
    if (p.lastModified) lines.push(`Last Modified: ${p.lastModified}`)
    if (p.canonical) lines.push(`Canonical: ${p.canonical}`)
    if (p.description) lines.push(`Description: ${p.description}`)
    if (p.robotsMeta) lines.push(`Robots: ${p.robotsMeta}`)
    if (p.meta?.keywords?.length) lines.push(`Keywords: ${p.meta.keywords.join(', ')}`)
    if (p.meta?.viewport) lines.push(`Viewport: ${p.meta.viewport}`)
    if (p.meta?.charset) lines.push(`Charset: ${p.meta.charset}`)
    if (p.meta?.generator) lines.push(`Generator: ${p.meta.generator}`)
    if (p.hreflang?.length) lines.push(`Alternate Locales: ${p.hreflang.map((h) => `${h.lang}:${h.href}`).join(' | ')}`)
    if (p.og && Object.keys(p.og).length) lines.push(`OpenGraph: ${JSON.stringify(p.og)}`)
    if (p.twitter && Object.keys(p.twitter).length) lines.push(`Twitter: ${JSON.stringify(p.twitter)}`)
    if (p.headings.length) {
      lines.push('Headings:')
      p.headings.slice(0, 30).forEach((h) => lines.push(`- ${h.tag.toUpperCase()}: ${h.text}`))
    }
    if (p.contentSnippet) {
      lines.push(`Word Count: ${p.wordCount}`)
      lines.push('Content Snippet:')
      lines.push(`> ${p.contentSnippet}`)
    }
    lines.push(`Links: internal=${p.internalLinks ?? 0}, external=${p.externalLinks ?? 0}`)
    if (p.links.length) {
      lines.push('Links sample:')
      p.links.slice(0, 20).forEach((l) => {
        const text = l.text || '(no text)'
        const rel = l.rel ? ` rel=${l.rel}` : ''
        lines.push(`- [${text}](${l.href})${rel}`)
      })
    }
    lines.push(`Images: total=${p.imageCount ?? 0} missingAlt=${p.imagesMissingAlt ?? 0}`)
    if (p.images?.length) {
      lines.push('Images sample:')
      p.images.slice(0, 15).forEach((img) => lines.push(`- ${img.src} alt="${img.alt ?? ''}"`))
    }
    if (p.jsonLd.length) lines.push('JSON-LD Types: ' + summarizeJsonLdTypes(p.jsonLd).join(', '))
    if (p.breadcrumbs?.length) lines.push('Breadcrumbs: ' + p.breadcrumbs.join(' > '))
    lines.push('')
  })

  return lines.join('\n') + '\n'
}

function summarizeJsonLdTypes(items: unknown[]): string[] {
  const out = new Set<string>()
  const visit = (v: any) => {
    if (!v) return
    if (Array.isArray(v)) {
      v.forEach(visit)
    } else if (typeof v === 'object') {
      const t = (v['@type'] as string) || undefined
      if (t) out.add(Array.isArray(t) ? t.join('+') : t)
      for (const k of Object.keys(v)) visit((v as any)[k])
    }
  }
  visit(items)
  return Array.from(out)
}

// New: Structured theme for more LLM-friendly, categorized Markdown
function toStructuredMarkdown(site: SiteSummary, pages: PageExtract[], options?: StructuredRenderOptions): string {
  const lines: string[] = []
  const now = site.generatedAt
  const totals = pages.reduce(
    (acc, p) => {
      acc.words += p.wordCount || 0
      acc.images += p.imageCount || 0
      acc.missingAlt += p.imagesMissingAlt || 0
      acc.internal += p.internalLinks || 0
      acc.external += p.externalLinks || 0
      return acc
    },
    { words: 0, images: 0, missingAlt: 0, internal: 0, external: 0 }
  )

  // Header
  lines.push('# llms.txt — Structured Site Summary')
  lines.push('Generated By: [llmoptimizer](https://github.com/ihuzaifashoukat/llmoptimizer) by Huzaifa Shoukat')
  if (site.baseUrl) lines.push(`Base URL: ${site.baseUrl}`)
  if (site.locales?.length) lines.push(`Locales: ${site.locales.join(', ')}`)
  lines.push(`Generated: ${now}`)
  lines.push(`Pages: ${pages.length}`)
  if (pages.length) {
    lines.push(
      `Totals: words=${totals.words} images=${totals.images} missingAlt=${totals.missingAlt} internalLinks=${totals.internal} externalLinks=${totals.external}`
    )
  }
  lines.push('')

  if (!pages.length) {
    lines.push('No pages found. If unexpected, try build-scan or provide baseUrl.')
    return lines.join('\n') + '\n'
  }

  // Categorize pages by URL/intent
  const groups = categorizePages(pages, options)
  const orderedKeys = orderCategoryKeys(Object.keys(groups), options)

  // Categories overview
  lines.push('## Categories')
  for (const key of orderedKeys) {
    const arr = groups[key]
    if (!arr?.length) continue
    lines.push(`- ${key}: ${arr.length}`)
  }
  lines.push('')

  // Quick index (flat list)
  lines.push('## Index')
  orderedKeys.forEach((key) => {
    const arr = groups[key]
    if (!arr?.length) return
    lines.push(`- ${key}`)
    arr.forEach((p) => {
      const title = p.title || p.url
      const desc = p.description ? ` — ${truncate(p.description, 120)}` : ''
      lines.push(`  - [${title}](${p.url})${desc}`)
    })
  })
  lines.push('')

  // Detailed, structured entries
  for (const key of orderedKeys) {
    const arr = groups[key]
    if (!arr?.length) continue
    lines.push(`## ${key} (${arr.length})`)
    lines.push('')
    arr.forEach((p, i) => {
      const anchor = `${slugify(key)}-${i + 1}`
      lines.push(`### ${p.title || p.url}`)
      lines.push(`<a id="${anchor}"></a>`)
      // Core metadata as JSON block for easy parsing
      const meta = buildPageMeta(p)
      lines.push('```json')
      lines.push(JSON.stringify(meta, null, 2))
      lines.push('```')

      // Compact human-readable sub-sections
      const maxH = options?.limits?.headings ?? 20
      const maxL = options?.limits?.links ?? 15
      const maxI = options?.limits?.images ?? 10
      if (p.headings?.length) {
        lines.push('Headings:')
        p.headings.slice(0, maxH).forEach((h) => lines.push(`- ${h.tag.toUpperCase()}: ${h.text}`))
      }
      if (p.contentSnippet) {
        lines.push('Content Snippet:')
        lines.push(`> ${p.contentSnippet}`)
      }
      if (p.links?.length) {
        lines.push('Links sample:')
        p.links.slice(0, maxL).forEach((l) => {
          const text = l.text || '(no text)'
          const rel = l.rel ? ` rel=${l.rel}` : ''
          lines.push(`- [${text}](${l.href})${rel}`)
        })
      }
      if (p.images?.length) {
        lines.push('Images sample:')
        p.images.slice(0, maxI).forEach((img) => lines.push(`- ${img.src} alt="${img.alt ?? ''}"`))
      }
      if (p.jsonLd?.length) lines.push('JSON-LD Types: ' + summarizeJsonLdTypes(p.jsonLd).join(', '))
      if (p.breadcrumbs?.length) lines.push('Breadcrumbs: ' + p.breadcrumbs.join(' > '))
      lines.push('')
    })
  }

  return lines.join('\n') + '\n'
}

function categorizePages(pages: PageExtract[], options?: StructuredRenderOptions): Record<string, PageExtract[]> {
  const groups: Record<string, PageExtract[]> = {}
  for (const p of pages) {
    const cat = inferCategory(p, options)
    if (!groups[cat]) groups[cat] = []
    groups[cat].push(p)
  }
  // stable sort within categories by URL
  for (const k of Object.keys(groups)) {
    groups[k] = groups[k].slice().sort((a, b) => (a.url < b.url ? -1 : a.url > b.url ? 1 : 0))
  }
  return groups
}

function orderCategoryKeys(keys: string[], options?: StructuredRenderOptions): string[] {
  const order = options?.categories?.order ?? [
    'Home',
    'Docs',
    'Guides',
    'API',
    'Blog',
    'Reference',
    'Products',
    'Product Categories',
    'Policies',
    'Important',
    'Company',
    'Legal',
    'Support',
    'Examples',
    'Other',
  ]
  const set = new Set(keys)
  const inOrder = order.filter((k) => set.has(k))
  const remaining = keys.filter((k) => !order.includes(k)).sort()
  return [...inOrder, ...remaining]
}

function inferCategory(p: PageExtract, options?: StructuredRenderOptions): string {
  const u = safePath(p.url)
  const h1 = p.headings?.find((h) => h.tag.toLowerCase() === 'h1')?.text.toLowerCase()

  // Configurable keyword mapping
  const cfg = options?.categories?.keywords
  if (cfg) {
    for (const [name, kws] of Object.entries(cfg)) {
      for (const kw of kws) {
        const k = kw.toLowerCase()
        if (u.includes(k) || (h1 && h1.includes(k))) return name
      }
    }
  }

  // Home
  if (u === '/' || u === '' || /\/(index|home)\/?$/.test(u)) return 'Home'
  // Explicit segments
  if (/\b(docs|documentation)\b/.test(u)) return 'Docs'
  if (/\b(guide|getting-started|tutorials?)\b/.test(u)) return 'Guides'
  if (/\b(api|reference\/api)\b/.test(u)) return 'API'
  if (/\b(blog|posts?|news)\b/.test(u)) return 'Blog'
  if (/\b(reference)\b/.test(u)) return 'Reference'
  if (/\b(products?|pricing|features|solutions?)\b/.test(u)) return 'Products'
  if (/\b(categories?|collections?|catalog)\b/.test(u)) return 'Product Categories'
  if (/\b(privacy|terms|cookies?|policy|policies|security|gdpr)\b/.test(u)) return 'Policies'
  if (/\b(important|status|uptime|login|signup|contact|support)\b/.test(u)) return 'Important'
  if (/\b(about|team|careers?)\b/.test(u)) return 'Company'
  if (/\b(legal)\b/.test(u)) return 'Legal'
  if (/\b(help|support|faq)\b/.test(u)) return 'Support'
  if (/\b(examples|showcase)\b/.test(u)) return 'Examples'
  // Heading hints
  if (h1?.includes('guide')) return 'Guides'
  if (h1?.includes('api')) return 'API'
  if (h1?.includes('reference')) return 'Reference'
  if (h1?.includes('blog')) return 'Blog'
  if (h1?.includes('product') || h1?.includes('pricing')) return 'Products'
  if (h1?.includes('policy') || h1?.includes('privacy') || h1?.includes('terms')) return 'Policies'
  return 'Other'
}

function buildPageMeta(p: PageExtract) {
  return {
    url: p.url,
    title: p.title ?? null,
    description: p.description ?? null,
    canonical: p.canonical ?? null,
    locale: p.locale ?? null,
    dir: p.dir ?? null,
    lastModified: p.lastModified ?? null,
    robots: p.robotsMeta ?? null,
    metrics: {
      wordCount: p.wordCount ?? 0,
      internalLinks: p.internalLinks ?? 0,
      externalLinks: p.externalLinks ?? 0,
      images: p.imageCount ?? 0,
      imagesMissingAlt: p.imagesMissingAlt ?? 0,
    },
    alternates: p.hreflang?.length ? p.hreflang : [],
    breadcrumbs: p.breadcrumbs?.length ? p.breadcrumbs : [],
    openGraph: p.og && Object.keys(p.og).length ? p.og : undefined,
    twitter: p.twitter && Object.keys(p.twitter).length ? p.twitter : undefined,
    samples: {
      links: (p.links || []).slice(0, 10).map((l) => ({ text: l.text || null, href: l.href, rel: l.rel || undefined })),
      images: (p.images || []).slice(0, 5),
      headings: (p.headings || []).slice(0, 12),
    },
  }
}

function truncate(s: string, n: number): string {
  if (!s) return s
  if (s.length <= n) return s
  return s.slice(0, Math.max(0, n - 1)) + '…'
}

function safePath(url: string): string {
  try {
    const u = new URL(url)
    return u.pathname.toLowerCase()
  } catch {
    return url.toLowerCase()
  }
}

function slugify(s: string): string {
  return s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '')
}
